<html lang="en">
    <head>
        <title>UEA Assassins: Duels Tournament @ HOST</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <link rel="stylesheet" href="/public/css/request_password.css">
        <link rel="stylesheet" href="/public/css/duels_t.css">
    </head>
    <body>
        <script src="/public/js/header.js"></script>


        <div id="overlay">
            <div id="request-password">
                <label for="password">Password</label>
                <input type="password" id="password" placeholder="Enter Password">
                <button onclick="setPassword()">Unlock</button>
            </div>
        </div>


        <div class="wrapper">
            <div class="content" id="main">
                <canvas id="canvas" width="1500px" height="600px"></canvas>
            </div>
        </div>

        <div class="wrapper">
            <button id="win_p1" onclick="setWinner('p1')" disabled>Player 1 Wins</button>
            <button id="btn-next" onclick="nextMatchup()">Next</button>
            <button id="win_p2" onclick="setWinner('p2')" disabled>Player 2 Wins</button>
        </div>

        <script>
            let unsecure_password = null;

            // THIS PASSWORD SYSTEM IS NOT SECURE, IT'S FOR VERY SMALL SCALE ONLY / TESTING

            function setPassword() {
                const passwordContainerEl = document.getElementById("request-password");
                const passwordEl = document.getElementById("password");

                fetch(`/host-validate?pass=${passwordEl.value}`)
                    .then(res => res.json())
                    .then(data => {
                        if (data.valid) {
                            unsecure_password = passwordEl.value;

                            document.getElementById("overlay").style.display = "none";
                            document.body.classList.remove("locked");
                        } else {
                            passwordEl.value = '';
                            alert("Invalid Password");
                        }
                    })
            }

            // Canvas System
            const contentDiv = document.getElementById("main");
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            const p1WinButton = document.getElementById("win_p1");
            const p2WinButton = document.getElementById("win_p2");
            const nextButton = document.getElementById("btn-next");

            let player_boxes = [];
            let players = {};
            let ready = false;
            let ingame = false;

            let p1 = null;
            let p2 = null;

            function nextMatchup() {
                if (!ingame) {
                    fetch(`/host/duels_t/start?pass=${unsecure_password}`)
                        .then(response => { ingame = true; reload(); })
                    return;
                }

                fetch(`/host/duels_t/current?pass=${unsecure_password}`)
                    .then(res => res.json())
                    .then(duel => {
                        if (duel.mode === "done") {
                            ingame = false;
                            ctx.fillStyle = "white";
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            return;
                        }

                        p1 = duel.p1;
                        p2 = duel.p2;

                        nextButton.disabled = true;

                        displayMatchup();
                    })
            }

            function setWinner(player) {
                if (!ready) { return; }

                let winner_name = p1;
                if (player !== "p1") {
                    winner_name = p2;
                }

                fetch(`/host/duels_t/on_win?pass=${unsecure_password}&winner=${winner_name}`)
                    .then(res => res.json())
                    .then(data => reload())
            }

            function drawBox(x, y, w, h, text, fill_colour=null) {
                if (fill_colour === null) {
                    fill_colour = "#fff";
                }

                ctx.fillStyle = fill_colour;
                ctx.fillRect(x, y, w, h);

                ctx.strokeStyle = "#222";
                ctx.strokeRect(x, y, w, h);

                ctx.fillStyle = "#222";
                ctx.font = "16px sans-serif";

                ctx.textAlign = "center";       // horizontal
                ctx.textBaseline = "middle";    // vertical

                ctx.fillText(text, x + w / 2, y + h / 2);
            }

            function redraw(brackets) {
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!brackets.length) {
                    return;
                }

                const first_bracket = brackets[0];

                const duo_slot_padding = 10;
                const vert_slot_padding = 10;
                const duo_connection_offset = 10;
                const connection_padding = 20;

                let bracket_width = canvas.width / ((brackets.length * 2) - 1);
                let duo_height = canvas.height / first_bracket.length;
                let slot_height = Math.max(20, duo_height / 2) - duo_slot_padding - vert_slot_padding;

                if (bracket_width > 200) {
                    bracket_width = 200;
                }

                const xOffset = (canvas.width / 2) - ((bracket_width * (brackets.length * 2 - 1)) / 2);

                player_boxes = [];

                brackets.forEach((bracket, i) => {
                    let bracket_player_boxes = []
                    const yOffset = (canvas.height / 2) - ((bracket.length * duo_height) / 2);

                    bracket.forEach((slot, j) => {
                        let p1 = "-";
                        let p2 = "-";
                        if (slot.p1) { p1 = players[slot.p1].display; }
                        if (slot.p2) { p2 = players[slot.p2].display; }

                        const x1 = xOffset + (i * bracket_width * 2);
                        const y1 = yOffset + (j * duo_height) + (vert_slot_padding/2);
                        const x2 = xOffset + (i * bracket_width * 2);
                        const y2 = yOffset + (j * duo_height) + slot_height + (vert_slot_padding/2) + duo_slot_padding;

                        let colour1 = "#fff"
                        let colour2 = "#fff"

                        if (slot.mode === "won_p1") {
                            colour1 = "#B4FFA8";
                            colour2 = "#FF8787";
                        } else if (slot.mode === "won_p2") {
                            colour1 = "#FF8787";
                            colour2 = "#B4FFA8";
                        }

                        if (slot.mode === "solo") {
                            colour2 = "#BDBDBD";

                            if (slot.p1) {
                                colour1 = "#B4FFA8";
                            }
                        }

                        bracket_player_boxes.push([ x1, y1, x2, y2 ])
                        drawBox( x1, y1, bracket_width, slot_height, p1, colour1);
                        drawBox( x2, y2, bracket_width, slot_height, p2, colour2);

                        const start_x1 = x1 + bracket_width;
                        const start_y1 = y1 + slot_height / 2;
                        const start_x2 = x2 + bracket_width;
                        const start_y2 = y2 + slot_height / 2;

                        ctx.beginPath();
                        ctx.moveTo(start_x1, start_y1);
                        ctx.lineTo(start_x1 + duo_connection_offset, start_y1);
                        ctx.lineTo(start_x2 + duo_connection_offset, start_y2);
                        ctx.lineTo(start_x2, start_y2);
                        ctx.stroke()

                    })

                    player_boxes.push(bracket_player_boxes);

                    // If Not the first bracket ->  Draw Connections
                    if (i !== 0) {
                        const previous_bracket = brackets[i - 1];
                        const previous_boxes = player_boxes[i - 1];
                        const current_boxes = player_boxes[i];

                        previous_bracket.forEach((previous_duel, k) => {
                            const pointer = previous_duel.next;

                            const start_y1 = previous_boxes[k][1] + slot_height / 2;
                            const start_y2 = previous_boxes[k][3] + slot_height / 2;

                            const start_x = previous_boxes[k][0] + bracket_width + duo_connection_offset;
                            const start_y = start_y1 + (start_y2 - start_y1) / 2;

                            const box_index = Math.floor(pointer / 2);
                            const sub_offset = (pointer % 2) * 2;

                            const end_x = current_boxes[box_index][sub_offset];
                            const end_y = current_boxes[box_index][sub_offset+1] + slot_height / 2;

                            const middle_x_offset = duo_connection_offset + (connection_padding / 2) + ((bracket_width - connection_padding - duo_connection_offset) / previous_bracket.length) * k;

                            ctx.beginPath();
                            ctx.moveTo(start_x, start_y);
                            ctx.lineTo(start_x + middle_x_offset, start_y);
                            ctx.lineTo(start_x + middle_x_offset, end_y);
                            ctx.lineTo(end_x, end_y);
                            ctx.stroke()
                        })

                    }
                })
            }

            function drawMatchupFrame(t) {
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                let x1;
                let x2;
                let y1 = canvas.height / 3;
                let y2 = (canvas.height / 3) * 2;
                let vs_brightness = 0;

                if (t < 0.2) {
                    const delta = (canvas.width / 3) * ((t - 0.1) * 10);
                    x1 = delta;
                    x2 = canvas.width - delta;
                    vs_brightness = 1 - (t * 2);
                } else if (t < 0.7) {
                    const delta = (t - 0.2) * (canvas.width / 12) * 2;
                    x1 = (canvas.width / 3) + delta;
                    x2 = canvas.width - x1;
                } else {
                    const delta = (t - 0.7) * 3.33 * canvas.width;
                    x1 = (canvas.width / 3) + (canvas.width / 12) + delta;
                    x2 = canvas.width - x1;
                    vs_brightness = (t - 0.7) * 3.33;
                }

                ctx.fillStyle = "#222";
                ctx.font = "32px sans-serif";

                ctx.fillText(players[p1].display, x1, y1);
                ctx.fillText(players[p2].display, x2, y2);

                ctx.fillStyle = `rgb(${vs_brightness * 255}, ${vs_brightness * 255}, ${vs_brightness * 255})`;

                ctx.fillText("vs", (canvas.width / 2), (canvas.height / 2));

                if (t >= 1) {
                    ctx.fillStyle = "#222";
                    ctx.font = "32px sans-serif";

                    ctx.fillText(`${players[p1].display}   vs   ${players[p2].display}`, (canvas.width / 2), (canvas.height / 2));

                    p1WinButton.disabled = false;
                    p2WinButton.disabled = false;
                }

            }

            function displayMatchup() {
                if (ready) {
                    animate(2000, drawMatchupFrame)
                }
            }

            function animate(duration, draw) {
                ready = false; // Ensure we cant start reload shit in the middle of an animation

                let start = null;

                function frame(timestamp) {
                    if (!start) start = timestamp;

                    const elapsed = timestamp - start;
                    const t = Math.min(elapsed / duration, 1);

                    draw(t);

                    if (t < 1) {
                        requestAnimationFrame(frame);
                    } else {
                        ready = true;
                    }
                }

                requestAnimationFrame(frame);
            }


            async function init() {
                // wait until unsecure_password becomes truthy
                while (!unsecure_password) {
                    await new Promise(r => setTimeout(r, 50));
                }

                const res = await fetch(`/host/duels_t/players?pass=${unsecure_password}`);
                players = await res.json();
                ready = true;
            }

            async function reload() {
                // wait until players are loaded
                while (!ready) {
                    await new Promise(r => setTimeout(r, 50));
                }

                const res = await fetch(`/host/duels_t/bracket?pass=${unsecure_password}`);
                const bracket = await res.json();
                redraw(bracket);

                p1WinButton.disabled = true;
                p2WinButton.disabled = true;
                nextButton.disabled = false;
            }


            init();
            reload();
        </script>
    </body>
</html>